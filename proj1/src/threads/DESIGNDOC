			+--------------------+
			|        CS 140      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

Caleb Simmeth <simmeth@usc.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.


>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

None.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

The sleeping_sema is an expanded semaphore element that can be placed 
in a list, and records the time that the thread should wake.
struct sleeping_sema
  {
    struct list_elem elem;
	int64_t waituntil;
	struct semaphore sema;
  }

Added to timer.c:

struct list waiting_list

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

On a call to timer_sleep, a new sleeping_sema is created which records
the time that the thread should wake. The sleeping_sema is added to the 
waiting_list, and sema_down is called so that the thread blocks
on the semaphore.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

When a thread is placed in the waiting list, it is placed in sorted order.
This means that to find the thread with the earliest sleep time,the 
interrupt handler just has to look at the front of the list, an O(1) 
operation. Also, the handler does not have to look at every element in
the list. As soon as it finds an element that it will not wake, it
can safely ignore the rest of the elements.


---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

Because interrupts are disabled during the critical section where
the waiting_list is modified, only one thread will have access to
if at a time.
Each thread is inserted in order, so it doesn't matter if one thread
accesses the list before the other.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

Interrupts are disabled during access of the waiting_list, and that is
the only shared element, so this will have no affect.

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

I chose this design because it is simple, and because it minimizes the
time spent in the interrupt handler. I considered putting element in the
waiting_list in unsorted order, and then using list_max to check if they 
have waited long enough, but that gives the interrupt the O(n) function
rather than the sleeping thread.

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.



>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
